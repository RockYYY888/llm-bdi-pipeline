# Stage 1 LTLf Generation Test Analysis
**Date**: 2025-11-03
**Test Run**: 20 test cases
**Success Rate**: 75% (15/20 passed)

## Summary

After fixing the formula comparison bug (comma splitting issue), the actual success rate is 75%, significantly better than the initially reported 20%. There are 5 genuine failure cases that need attention.

---

## Bug Fixed

**Issue**: The `compare_formulas` function was naively splitting on commas, which incorrectly split predicates like `on(a, b)` into `["on(a", "b)"]`.

**Solution**: Implemented `split_formulas()` function that respects parentheses depth when splitting comma-separated formulas.

```python
def split_formulas(formula_string: str) -> List[str]:
    """Split comma-separated formulas while respecting parentheses"""
    # Tracks parenthesis depth to split only at top level
```

---

## Genuine Failure Cases (5)

### 1. **Test #8: Until Operator - Extra Parentheses**
```
NL: "Keep holding a until b is clear"
Expected: holding(a) U clear(b)
Actual:   (holding(a) U clear(b))
```

**Problem**: LLM adds outer parentheses around the entire Until formula.

**Root Cause**: The LLM might be following a convention to parenthesize binary operators for clarity.

**Is it actually wrong?**: Mathematically, `(φ U ψ)` and `φ U ψ` are equivalent. The parentheses are redundant but not incorrect.

**Recommended Action**:
- **Option A**: Update expected to include parentheses: `(holding(a) U clear(b))`
- **Option B**: Modify normalize_formula to strip outer parentheses
- **Option C**: Update prompt to specify "do not add outer parentheses"

**Decision**: Option B is best - normalize away cosmetic differences.

---

### 2. **Test #13: Over-specification - F(G()) instead of F()**
```
NL: "Make sure block a has nothing on top"
Expected: F(clear(a))
Actual:   F(G(clear(a)))
```

**Problem**: LLM interprets "make sure" as "ensure it stays that way forever" → adds G operator.

**Analysis**:
- "Make sure" is ambiguous - could mean:
  - F(clear(a)): Eventually achieve clear(a)
  - F(G(clear(a))): Eventually achieve and maintain clear(a) forever

**Root Cause**: Natural language ambiguity. "Make sure" has maintenance connotation.

**Recommended Action**:
1. **Prompt Enhancement**: Add clarification in prompt:
   ```
   - "make sure", "ensure" without "keep/maintain" → F (Eventually)
   - "make sure X stays/remains Y" → F(G(φ))
   ```

2. **Test Case Update**: Change NL to be more explicit:
   - Current: "Make sure block a has nothing on top"
   - Better: "Clear block a" or "Ensure block a becomes clear"

**Decision**: Both - update prompt AND make test case less ambiguous.

---

### 3. **Test #14: Negation with Predicate Arguments**
```
NL: "Never put a on b"
Expected: G(not(on(a, b)))
Actual:   G(not(on))
```

**Problem**: LLM generates `not(on)` instead of `not(on(a, b))` - missing predicate arguments!

**Analysis**: This is a critical bug. The negation is applied to the predicate name only, not the full predicate with arguments.

**Root Cause**: Prompt may not have clear examples showing negation with multi-argument predicates.

**Recommended Action**:
1. **Prompt Enhancement**: Add explicit negation examples:
   ```
   Example: "Never put A on B"
   → G(not(on(a, b))): NOT "G(not(on))"

   Important: Negation applies to the COMPLETE predicate including arguments.
   Correct: not(on(a, b))
   Wrong: not(on)
   ```

2. **Verify LLM Response Parsing**: Check if the LTL parser is correctly handling the JSON response.

**Decision**: HIGH PRIORITY - Add negation examples to prompt.

---

### 4. **Test #17: Nullary Predicate with Empty Parentheses**
```
NL: "Keep the hand empty"
Expected: G(handempty)
Actual:   G(handempty())
```

**Problem**: LLM adds empty parentheses `()` to nullary predicate `handempty`.

**Analysis**:
- `handempty()` vs `handempty` - both represent the same nullary predicate
- In PDDL: `handempty` is correct (no parentheses for 0-arity predicates)
- In some logics: `handempty()` is acceptable notation

**Is it actually wrong?**: Technically yes - PDDL convention is no parentheses for nullary predicates.

**Recommended Action**:
1. **Prompt Enhancement**: Clarify parentheses usage:
   ```
   Predicate Format:
   - Multi-argument: predicate(arg1, arg2, ...)
     Example: on(a, b), holding(x)
   - Nullary (no arguments): predicate (NO parentheses)
     Example: handempty (NOT handempty())
   ```

2. **Normalize Function**: Add post-processing to remove `()` from nullary predicates:
   ```python
   # Remove empty parentheses from nullary predicates
   normalized = re.sub(r'\(\s*\)', '', normalized)
   ```

**Decision**: Option 2 (normalization) is simpler and more robust.

---

### 5. **Test #20: Conjunction Within Temporal Operator - CRITICAL ERROR**
```
NL: "Eventually a is on b and c is on d at the same time"
Expected: F(on(a, b) & on(c, d))
Actual:   (ERROR: sequence item 0: expected str instance, dict found)
```

**Problem**: LLM response parsing failed completely. Error suggests the JSON response has incorrect structure.

**Root Cause**: The LLM might be generating:
```json
{
  "ltl_formulas": [
    {
      "type": "conjunction",  // Wrong! Should be "temporal"
      "formulas": [{"on": ["a", "b"]}, {"on": ["c", "d"]}]
    }
  ]
}
```

Or trying to represent logical conjunction differently from our expected format.

**Current Prompt Format**: Prompt doesn't clearly specify how to handle logical operators (& , |, not) WITHIN temporal formulas.

**Recommended Action**:
1. **Prompt Enhancement**: Add examples of logical operators within temporal formulas:
   ```
   Complex Formulas with Logical Operators:

   Example: "Eventually A and B hold together"
   → Use logical_operator format:
   {
     "type": "temporal",
     "operator": "F",
     "formula": {
       "logical_op": "and",
       "formulas": [
         {"on": ["a", "b"]},
         {"on": ["c", "d"]}
       ]
     }
   }

   Note: Logical operators (&, |, not) appear INSIDE temporal formulas.
   ```

2. **Parser Enhancement**: Update LTL parser to handle logical operators within formulas.

3. **Error Handling**: Add better error messages to identify JSON structure issues.

**Decision**: HIGH PRIORITY - Prompt needs logical operator support.

---

## Prompt Improvement Recommendations

### Priority 1: Critical Issues

1. **Add Negation with Arguments** (Test #14)
   - Current: No examples of negation with multi-argument predicates
   - Add: `"Never put A on B" → G(not(on(a, b)))`
   - Emphasize: "Negation includes ALL predicate arguments"

2. **Add Logical Operators Within Temporal Formulas** (Test #20)
   - Current: No specification for & , | , not within F(), G(), etc.
   - Add: Complete JSON format for logical operators
   - Add: Multiple examples showing this pattern

### Priority 2: Clarifications

3. **Clarify "Make Sure" vs "Keep" Semantics** (Test #13)
   - Add: Natural language pattern disambiguation
   - "make sure" → F() (achieve once)
   - "make sure X stays/remains" → F(G()) (achieve and maintain)

4. **Clarify Nullary Predicates** (Test #17)
   - Add: Explicit format for 0-argument predicates
   - "handempty (NO parentheses)"

### Priority 3: Cosmetic Normalization

5. **Normalize Until Operator Parentheses** (Test #8)
   - Modify normalize_formula() to strip outer parentheses
   - Both `φ U ψ` and `(φ U ψ)` should normalize identically

---

## Updated Prompt Additions

### Section to Add: "Logical Operators Within Temporal Formulas"

```
**Logical Operators Inside Temporal Formulas:**

When combining multiple predicates with AND, OR, or NOT inside a temporal operator:

1. Simple conjunction: "Eventually A and B both hold"
   {
     "type": "temporal",
     "operator": "F",
     "formula": {
       "logical_op": "and",
       "sub_formulas": [
         {"on": ["a", "b"]},
         {"on": ["c", "d"]}
       ]
     }
   }

2. Negation: "Never put A on B" = "Always NOT on(A,B)"
   {
     "type": "temporal",
     "operator": "G",
     "formula": {
       "logical_op": "not",
       "sub_formula": {"on": ["a", "b"]}
     }
   }

**IMPORTANT**:
- Negation must include FULL predicate: not(on(a,b)) NOT not(on)
- Logical operators (&, |, not) work INSIDE temporal formulas
- Multiple separate goals use MULTIPLE ltl_formulas entries
```

### Section to Add: "Predicate Argument Rules"

```
**Predicate Formatting:**

1. Multi-argument predicates: ALWAYS include parentheses with arguments
   - on(a, b)
   - holding(x)

2. Nullary predicates (no arguments): NO parentheses
   - handempty
   - NOT handempty()

3. Negation: Include COMPLETE predicate with arguments
   - Correct: not(on(a, b))
   - Wrong: not(on)
```

---

## Next Steps

1. **Update prompt file**: `src/stage1_interpretation/prompts.py`
   - Add logical operator examples
   - Add negation with arguments examples
   - Clarify nullary predicate format
   - Add "make sure" disambiguation

2. **Update normalize function**: `test_nl_to_ltlf_generation.py`
   - Strip outer parentheses from Until expressions
   - Remove empty `()` from predicates

3. **Fix test case #13**: Make NL instruction less ambiguous

4. **Re-run tests**: Verify improvements push success rate to 90%+

5. **Add parser support**: Handle logical operators within temporal formulas (if needed)

---

## Expected Improvements

After implementing recommended changes:

| Issue | Current Status | Expected Status |
|-------|---------------|-----------------|
| Test #8 (Until parens) | FAIL | **PASS** (normalization) |
| Test #13 (make sure) | FAIL | **PASS** (prompt + test update) |
| Test #14 (negation args) | FAIL | **PASS** (prompt fix) |
| Test #17 (nullary parens) | FAIL | **PASS** (normalization) |
| Test #20 (conjunction) | ERROR | **PASS** (prompt + parser fix) |

**Projected Success Rate**: 100% (20/20)
