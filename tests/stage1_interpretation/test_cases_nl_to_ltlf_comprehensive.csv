test_id,category,natural_language,expected_ltlf,expected_objects,description,notes
P01,propositional_constant_true,"Goal is always achievable","G(true)","[]",Propositional constant: true,Propositional Symbols
P02,propositional_atomic_nullary,"Keep the hand empty","G(handempty)","[]",Atomic proposition: nullary predicate,Propositional Symbols
P03,propositional_atomic_unary,"Eventually block a is clear","F(clear(a))","['a']",Atomic proposition: unary predicate,Propositional Symbols
P04,propositional_atomic_binary,"Eventually a is on b","F(on(a, b))","['a', 'b']",Atomic proposition: binary predicate,Propositional Symbols
B01,boolean_and,"Eventually a is on b and c is clear","F(on(a, b) & clear(c))","['a', 'b', 'c']",Boolean AND operator,Boolean Operators (And)
B02,boolean_or,"Eventually either a is on b or c is on d","F(on(a, b) | on(c, d))","['a', 'b', 'c', 'd']",Boolean OR operator,Boolean Operators (Or)
B03,boolean_not,"Never put a on b","G(!(on(a, b)))","['a', 'b']",Boolean NOT operator,Boolean Operators (Not)
B04,boolean_implies,"Eventually if a is clear then a is on b","F(clear(a) -> on(a, b))","['a', 'b']",Boolean IMPLIES operator,Boolean Operators (Implication)
B05,boolean_equivalence,"Eventually a is clear if and only if a is on table","F(clear(a) <-> ontable(a))","['a']",Boolean EQUIVALENCE operator,Boolean Operators (Equivalence)
T01,temporal_next,"Pick up a then immediately place on b","F(holding(a) & X(on(a, b)))","['a', 'b']",Temporal X (Next) operator - combined with AND,Future Temporal Operators (Next)
T02,temporal_weak_next,"In next state if exists a is on b","WX(on(a, b))","['a', 'b']",Temporal WX (WeakNext) operator,Future Temporal Operators (WeakNext)
T03,temporal_until,"Keep holding a until b is clear","(holding(a) U clear(b))","['a', 'b']",Temporal U (Until) operator,Future Temporal Operators (Until)
T04,temporal_release,"B stays clear unless a is placed on table","(ontable(a) R clear(b))","['a', 'b']",Temporal R (Release) operator,Future Temporal Operators (Release)
T05,temporal_eventually,"Put block a on block b","F(on(a, b))","['a', 'b']",Temporal F (Eventually) operator,Future Temporal Operators (Eventually)
T06,temporal_globally,"Always keep block a clear","G(clear(a))","['a']",Temporal G (Always) operator,Future Temporal Operators (Always)
N01,nested_fg,"Eventually ensure a is always on b","F(G(on(a, b)))","['a', 'b']",Nested temporal: F(G),Nested operators
N02,nested_gf,"Keep trying to clear c","G(F(clear(c)))","['c']",Nested temporal: G(F),Nested operators
C01,complex_bool_temporal,"Eventually either a on b and c clear or d on table","F(on(a, b) & clear(c) | ontable(d))","['a', 'b', 'c', 'd']",Complex: Boolean within temporal (precedence: & > |),Combined operators
C02,complex_temporal_bool,"Always if a is clear then eventually a is on b","G(clear(a) -> F(on(a, b)))","['a', 'b']",Complex: Temporal within boolean,Combined operators
C03,complex_until_conjunction,"Keep holding a and b clear until c is on d","(holding(a) & clear(b) U on(c, d))","['a', 'b', 'c', 'd']",Complex: Until with conjunction (outer parens ensure correct precedence),Combined operators
PRE01,precedence_unary_and,"Eventually on a b conjoined with always clear c","F(on(a, b)) & G(clear(c))","['a', 'b', 'c']",Precedence: Unary F and G bind tighter than binary & (unary has higher precedence),Operator Precedence
PRE02,precedence_and_or,"Eventually on a b and clear c or on d e","F(on(a, b) & clear(c) | on(d, e))","['a', 'b', 'c', 'd', 'e']",Precedence: AND groups before OR (& has higher precedence than |),Operator Precedence
PRE03,precedence_or_implies,"Always clear a or on a b implies eventually on c d","G(clear(a) | on(a, b) -> F(on(c, d)))","['a', 'b', 'c', 'd']",Precedence: OR groups before IMPLIES (| has higher precedence than ->),Operator Precedence
PRE04,precedence_until_and,"Hold a until clear b and on c d","(holding(a) U clear(b) & on(c, d))","['a', 'b', 'c', 'd']",Precedence: AND in right operand of Until (& has higher precedence than U),Operator Precedence
PRE05,precedence_neg_and,"Eventually not on a b and clear c","F(!(on(a, b)) & clear(c))","['a', 'b', 'c']",Precedence: Negation binds tighter than AND (! has higher precedence than &),Operator Precedence
