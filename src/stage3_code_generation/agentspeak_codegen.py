"""
AgentSpeak Code Generator

Generates AgentSpeak (.asl) code from state graphs produced by forward planning.

Following the design specification (Decision #12), generates:
1. PDDL action → AgentSpeak action goal plans (e.g., +!pickup(X))
   - Each includes external action calls
   - Explicit belief updates from PDDL effects
2. Goal achievement plans with:
   - Context-sensitive conditions
   - Precondition subgoals (recursive)
   - Action goal invocations
   - Recursive goal checking
3. Initial beliefs
4. Success and failure handlers

Design ref: docs/stage3_backward_planning_design.md Decision #12, Q&A #16
"""

from typing import List, Dict, Set, Optional, Tuple
from pathlib import Path
import sys

# Add parent directory to path
_parent = str(Path(__file__).parent.parent)
if _parent not in sys.path:
    sys.path.insert(0, _parent)

from stage3_code_generation.state_space import (
    PredicateAtom, WorldState, StateTransition, StateGraph
)
from stage3_code_generation.pddl_condition_parser import PDDLConditionParser, PDDLEffectParser
from utils.pddl_parser import PDDLDomain, PDDLAction


class AgentSpeakCodeGenerator:
    """
    Generate AgentSpeak code from state graph

    Implements the design specification for AgentSpeak generation:
    - PDDL actions → AgentSpeak action goal plans
    - Goal plans with precondition subgoals
    - Belief updates
    - Jason-compatible syntax
    """

    def __init__(self, state_graph: StateGraph, goal_name: str,
                 domain: PDDLDomain, objects: List[str]):
        """
        Initialize code generator

        Args:
            state_graph: State graph from forward planning
            goal_name: Name of the goal (e.g., "on(a, b)")
            domain: PDDL domain (for action definitions)
            objects: List of objects in domain
        """
        self.graph = state_graph
        self.goal_name = goal_name
        self.domain = domain
        self.objects = objects
        self.condition_parser = PDDLConditionParser()
        self.effect_parser = PDDLEffectParser()

    def generate(self) -> str:
        """
        Generate complete AgentSpeak code

        Returns:
            AgentSpeak .asl file content
        """
        sections = []

        # Header
        sections.append(self._generate_header())

        # Initial beliefs
        sections.append(self._generate_initial_beliefs())

        # PDDL action definitions (as AgentSpeak action goal plans)
        sections.append(self._generate_action_plans())

        # Goal achievement plans
        sections.append(self._generate_goal_plans())

        # Success handler
        sections.append(self._generate_success_plan())

        # Failure handler
        sections.append(self._generate_failure_plan())

        return "\n\n".join(sections)

    def _generate_header(self) -> str:
        """Generate file header"""
        stats = self.graph.get_statistics()
        return f"""/* AgentSpeak Plan Library
 * Generated by Backward Planning (non-LLM)
 *
 * Goal: {self.goal_name}
 * Objects: {', '.join(self.objects)}
 *
 * Statistics:
 *   States: {stats['num_states']}
 *   Transitions: {stats['num_transitions']}
 *   Goal Plans: {len(self.graph.find_shortest_paths_to_goal()) - 1}
 *   Action Plans: {len(self.domain.actions)}
 */"""

    def _generate_initial_beliefs(self) -> str:
        """
        Generate initial beliefs

        For blocksworld: all blocks on table, hand empty, all clear
        Design ref: Decision #14
        """
        lines = ["/* Initial Beliefs */"]

        # Blocksworld-specific initial beliefs
        for obj in self.objects:
            lines.append(f"ontable({obj}).")
            lines.append(f"clear({obj}).")

        lines.append("handempty.")

        return "\n".join(lines)

    def _generate_action_plans(self) -> str:
        """
        Generate PDDL action → AgentSpeak action goal plans

        Design ref: Decision #12

        For each PDDL action, generates:
        +!action_name(Args) : preconditions <-
            external_action(Args);
            +effect1;
            -effect2;
            ...

        Returns:
            Action plans section
        """
        lines = ["/* PDDL Action Plans (as AgentSpeak goals) */"]
        lines.append("/* Each PDDL action is converted to an AgentSpeak goal plan */")
        lines.append("/* with explicit belief updates from PDDL effects */")

        # Collect all unique actions used in the state graph
        used_actions = set()
        for transition in self.graph.transitions:
            used_actions.add(transition.action.name)

        # Generate action plans only for used actions
        for action in self.domain.actions:
            if action.name not in used_actions:
                continue  # Skip unused actions

            # Generate all groundings for this action
            action_plans = self._generate_action_plan_variants(action)
            lines.extend(action_plans)

        return "\n\n".join(lines)

    def _generate_action_plan_variants(self, action: PDDLAction) -> List[str]:
        """
        Generate AgentSpeak plans for all groundings of a PDDL action

        Args:
            action: PDDL action

        Returns:
            List of AgentSpeak action plans
        """
        plans = []

        # Get action parameter variables
        param_vars = []
        for param in action.parameters:
            parts = param.split('-')
            if parts:
                var_name = parts[0].strip()
                param_vars.append(var_name)

        # If no parameters, generate single plan
        if not param_vars:
            plan = self._generate_single_action_plan(action, [], {})
            if plan:
                plans.append(plan)
            return plans

        # For parametric actions, generate generic plan with variables
        # (AgentSpeak will handle grounding at runtime)
        plan = self._generate_parametric_action_plan(action, param_vars)
        if plan:
            plans.append(plan)

        return plans

    def _generate_parametric_action_plan(self, action: PDDLAction, param_vars: List[str]) -> Optional[str]:
        """
        Generate parametric action plan (with variables)

        Args:
            action: PDDL action
            param_vars: Parameter variables (e.g., ["?b1", "?b2"])

        Returns:
            AgentSpeak plan string
        """
        # Convert action name to valid AgentSpeak identifier
        action_name = action.name.replace('-', '_')

        # Parse preconditions (keep variables)
        try:
            # For parametric plan, we don't bind variables yet
            # Just format the precondition string
            precond_str = action.preconditions
            if precond_str and precond_str != "none":
                # Convert PDDL preconditions to AgentSpeak format
                # This is simplified - just extract predicates
                context = self._format_pddl_condition_as_agentspeak(precond_str, param_vars)
            else:
                context = "true"
        except Exception as e:
            print(f"Warning: Failed to parse preconditions for {action.name}: {e}")
            context = "true"

        # Parse effects (keep variables)
        try:
            # Extract belief updates from effects
            belief_updates = self._extract_belief_updates_parametric(action.effects, param_vars)
        except Exception as e:
            print(f"Warning: Failed to parse effects for {action.name}: {e}")
            belief_updates = []

        # Format parameters for plan header
        if param_vars:
            # Convert ?b1 to B1, ?b2 to B2 (AgentSpeak style)
            agentspeak_vars = [v.lstrip('?').upper() if v.startswith('?') else v.upper()
                              for v in param_vars]
            params_str = ", ".join(agentspeak_vars)
            external_call = f"{action_name}_physical({params_str})"
        else:
            params_str = ""
            external_call = f"{action_name}_physical"

        # Build plan
        body_lines = [external_call]
        body_lines.extend(belief_updates)

        body = ";\n    ".join(body_lines)

        if params_str:
            plan = f"+!{action_name}({params_str}) : {context} <-\n    {body}."
        else:
            plan = f"+!{action_name} : {context} <-\n    {body}."

        return plan

    def _generate_single_action_plan(self, action: PDDLAction, args: List[str],
                                     bindings: Dict[str, str]) -> Optional[str]:
        """
        Generate single grounded action plan

        Args:
            action: PDDL action
            args: Ground arguments
            bindings: Variable bindings

        Returns:
            AgentSpeak plan string
        """
        # Convert action name
        action_name = action.name.replace('-', '_')

        # Parse preconditions with bindings
        try:
            precond_predicates = self.condition_parser.parse(action.preconditions, bindings)
            if precond_predicates:
                context = " & ".join(p.to_agentspeak() for p in precond_predicates)
            else:
                context = "true"
        except:
            context = "true"

        # Parse effects with bindings
        try:
            effect_branches = self.effect_parser.parse(action.effects, bindings)
            # Use first branch (non-determinism handled elsewhere)
            belief_updates = []
            if effect_branches:
                for effect_atom in effect_branches[0]:
                    belief_updates.append(effect_atom.to_agentspeak())
        except:
            belief_updates = []

        # Build plan
        if args:
            args_str = ", ".join(args)
            external_call = f"{action_name}_physical({args_str})"
            plan_header = f"+!{action_name}({args_str})"
        else:
            external_call = f"{action_name}_physical"
            plan_header = f"+!{action_name}"

        body_lines = [external_call]
        body_lines.extend(belief_updates)

        body = ";\n    ".join(body_lines)

        plan = f"{plan_header} : {context} <-\n    {body}."

        return plan

    def _format_pddl_condition_as_agentspeak(self, condition: str, param_vars: List[str]) -> str:
        """
        Convert PDDL condition to AgentSpeak format (simplified)

        Args:
            condition: PDDL condition string
            param_vars: Parameter variables

        Returns:
            AgentSpeak context string
        """
        # Simplified conversion - just handle basic cases
        # Replace '?var' with 'VAR'
        result = condition
        for var in param_vars:
            if var.startswith('?'):
                agentspeak_var = var.lstrip('?').upper()
                result = result.replace(var, agentspeak_var)

        # Remove 'and' wrapper
        result = result.strip()
        if result.startswith('and'):
            result = result[3:].strip()

        # Remove outer parentheses if present
        if result.startswith('(') and result.endswith(')'):
            result = result[1:-1].strip()

        # Convert predicates: (handempty) -> handempty
        # (clear ?b1) -> clear(B1)
        # This is simplified - full implementation would parse properly
        result = result.replace('(', '').replace(')', '')

        # Basic cleanup
        result = result.replace('  ', ' ')

        return result if result else "true"

    def _extract_belief_updates_parametric(self, effects: str, param_vars: List[str]) -> List[str]:
        """
        Extract belief updates from PDDL effects (parametric)

        Args:
            effects: PDDL effects string
            param_vars: Parameter variables

        Returns:
            List of belief update strings
        """
        # Simplified extraction
        updates = []

        # Replace variables
        effect_str = effects
        for var in param_vars:
            if var.startswith('?'):
                agentspeak_var = var.lstrip('?').upper()
                effect_str = effect_str.replace(var, agentspeak_var)

        # Very simplified parsing - just look for (not and predicates
        # Full implementation would use effect parser
        import re

        # Find all (not (predicate ...))
        not_pattern = r'\(not\s+\(([a-zA-Z][a-zA-Z0-9_-]*)\s*([^)]*)\)\)'
        for match in re.finditer(not_pattern, effect_str):
            pred_name = match.group(1)
            pred_args = match.group(2).strip()
            if pred_args:
                updates.append(f"-{pred_name}({pred_args})")
            else:
                updates.append(f"-{pred_name}")

        # Find all positive predicates
        pos_pattern = r'\(([a-zA-Z][a-zA-Z0-9_-]*)\s+([^)]+)\)'
        for match in re.finditer(pos_pattern, effect_str):
            pred_name = match.group(1)
            if pred_name in ['and', 'or', 'not', 'oneof']:
                continue
            pred_args = match.group(2).strip()
            # Check if already captured as negative
            if not any(f"-{pred_name}" in u for u in updates):
                if pred_args:
                    updates.append(f"+{pred_name}({pred_args})")
                else:
                    updates.append(f"+{pred_name}")

        return updates

    def _generate_goal_plans(self) -> str:
        """
        Generate plans for achieving the goal

        Design ref: Decision #9, Q&A #16

        For each non-goal state, generate a plan showing how to progress
        toward the goal with precondition subgoals.
        """
        lines = [f"/* Goal Achievement Plans for: {self.goal_name} */"]
        lines.append("/* Each plan handles a specific state and invokes action goals */")

        # Find shortest paths to goal for all states
        paths = self.graph.find_shortest_paths_to_goal()

        # Generate plans for states that have paths to goal
        plan_count = 0
        for state, path in paths.items():
            if state == self.graph.goal_state:
                # Skip goal state (handled by success plan)
                continue

            if not path:
                # No path to goal
                continue

            # Skip states where goal is already satisfied
            # In destructive planning, many states contain goal predicates
            goal_predicates = self.graph.goal_state.predicates
            if goal_predicates.issubset(state.predicates):
                # Goal already satisfied in this state, skip
                continue

            plan = self._generate_plan_for_state(state, path)
            if plan:
                lines.append(plan)
                plan_count += 1

        if plan_count == 0:
            lines.append("/* No intermediate plans needed - goal directly achievable */")

        return "\n\n".join(lines)

    def _generate_plan_for_state(self, state: WorldState,
                                  path: List[StateTransition]) -> Optional[str]:
        """
        Generate AgentSpeak plan for a specific state

        Design ref: Decision #9

        Plan structure:
        +!goal_name : context <-
            !precond1;      // Precondition subgoals
            !precond2;
            !action_goal(args);  // Action goal invocation
            !goal_name.     // Recursive check

        Args:
            state: Current state
            path: Path to goal (list of transitions)

        Returns:
            AgentSpeak plan string
        """
        if not path:
            return None

        # Get next transition in path
        next_transition = path[0]

        # Format context
        context = state.to_agentspeak_context()

        # Format action goal invocation (not direct action call)
        action_goal = self._format_action_goal_invocation(
            next_transition.action,
            next_transition.action_args
        )

        # Build plan body
        # Note: We don't generate precondition subgoals here because we have
        # a complete path from this state to the goal. The path finding ensures
        # that transitions are valid and preconditions will be met.
        # Design ref: Decision #9 - path-based plan generation
        body_lines = []
        body_lines.append(action_goal)    # Action goal invocation
        body_lines.append(f"!{self.goal_name}")  # Recursive goal check

        # Format body
        body = ";\n    ".join(body_lines)

        # Generate plan
        plan = f"+!{self.goal_name} : {context} <-\n    {body}."

        return plan

    def _format_action_goal_invocation(self, action: PDDLAction, args: List[str]) -> str:
        """
        Format action goal invocation

        Args:
            action: PDDL action
            args: Ground arguments

        Returns:
            Action goal invocation string (e.g., "!pick_up(a, b)")
        """
        action_name = action.name.replace('-', '_')

        if args:
            args_str = ", ".join(args)
            return f"!{action_name}({args_str})"
        return f"!{action_name}"

    def _predicate_to_goal_invocation(self, predicate: PredicateAtom) -> str:
        """
        Convert predicate to goal invocation

        Args:
            predicate: PredicateAtom

        Returns:
            Goal invocation string (e.g., "!clear(b)")
        """
        # For now, just use the predicate as goal name
        # More sophisticated mapping could be added
        return f"!{predicate.to_agentspeak()}"

    def _generate_success_plan(self) -> str:
        """Generate plan for when goal is already achieved"""
        context = self.graph.goal_state.to_agentspeak_context()

        return f"""+!{self.goal_name} : {context} <-
    .print("Goal {self.goal_name} already achieved!")."""

    def _generate_failure_plan(self) -> str:
        """Generate failure handler"""
        return f"""-!{self.goal_name} : true <-
    .print("Failed to achieve goal {self.goal_name}");
    .fail."""


# Test function
def test_agentspeak_codegen():
    """Test AgentSpeak code generator"""
    print("="*80)
    print("Testing AgentSpeak Code Generator (Improved)")
    print("="*80)

    # Create mock state graph
    from utils.pddl_parser import PDDLParser

    # Load domain
    domain_file = Path(__file__).parent.parent / "legacy" / "fond" / "domains" / "blocksworld" / "domain.pddl"

    if not domain_file.exists():
        print(f"Domain file not found: {domain_file}")
        print("Skipping test")
        return

    domain = PDDLParser.parse_domain(str(domain_file))

    # Create simple state graph
    goal_state = WorldState({PredicateAtom("on", ["a", "b"])}, depth=0)
    state1 = WorldState({
        PredicateAtom("holding", ["a"]),
        PredicateAtom("clear", ["b"])
    }, depth=1)
    state2 = WorldState({
        PredicateAtom("ontable", ["a"]),
        PredicateAtom("clear", ["a"]),
        PredicateAtom("clear", ["b"]),
        PredicateAtom("handempty", [])
    }, depth=2)

    graph = StateGraph(goal_state)

    # Find actions
    action_putonblock = None
    action_pickupfromtable = None
    for action in domain.actions:
        if action.name == "put-on-block":
            action_putonblock = action
        elif action.name == "pick-up-from-table":
            action_pickupfromtable = action

    if not action_putonblock or not action_pickupfromtable:
        print("Required actions not found in domain")
        return

    # Add transitions
    trans1 = StateTransition(
        from_state=state1,
        to_state=goal_state,
        action=action_putonblock,
        action_args=["a", "b"],
        belief_updates=["+on(a, b)", "+handempty", "+clear(a)", "-holding(a)", "-clear(b)"],
        preconditions=[PredicateAtom("holding", ["a"]), PredicateAtom("clear", ["b"])]
    )
    graph.add_transition(trans1)

    trans2 = StateTransition(
        from_state=state2,
        to_state=state1,
        action=action_pickupfromtable,
        action_args=["a"],
        belief_updates=["+holding(a)", "-handempty", "-ontable(a)"],
        preconditions=[PredicateAtom("handempty", []), PredicateAtom("clear", ["a"]), PredicateAtom("ontable", ["a"])]
    )
    graph.add_transition(trans2)

    # Generate code
    codegen = AgentSpeakCodeGenerator(
        state_graph=graph,
        goal_name="on(a, b)",
        domain=domain,
        objects=["a", "b"]
    )

    asl_code = codegen.generate()

    print("\nGenerated AgentSpeak Code:")
    print("="*80)
    print(asl_code)
    print("="*80)

    # Save to file
    output_file = Path(__file__).parent / "test_agentspeak_improved.asl"
    with open(output_file, 'w') as f:
        f.write(asl_code)

    print(f"\nSaved to: {output_file}")
    print()


if __name__ == "__main__":
    test_agentspeak_codegen()
