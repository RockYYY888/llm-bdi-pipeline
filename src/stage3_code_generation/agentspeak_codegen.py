"""
AgentSpeak Code Generator

Generates AgentSpeak (.asl) code from state graphs produced by forward planning.

For each non-goal state in the graph, generates:
- Context-sensitive plans with precondition subgoals
- Action calls with belief updates
- Recursive goal invocations

Also generates:
- Action definitions (PDDL actions â†’ AgentSpeak actions)
- Initial beliefs
- Success and failure handlers
"""

from typing import List, Dict, Set, Optional
from pathlib import Path
import sys

# Add parent directory to path
_parent = str(Path(__file__).parent.parent)
if _parent not in sys.path:
    sys.path.insert(0, _parent)

from stage3_code_generation.state_space import (
    PredicateAtom, WorldState, StateTransition, StateGraph
)
from utils.pddl_parser import PDDLDomain, PDDLAction


class AgentSpeakCodeGenerator:
    """
    Generate AgentSpeak code from state graph

    Takes a StateGraph (from forward planning) and generates complete
    AgentSpeak .asl file with:
    - Plans for achieving the goal from different states
    - Action definitions with belief updates
    - Initial beliefs
    - Success/failure handlers
    """

    def __init__(self, state_graph: StateGraph, goal_name: str,
                 domain: PDDLDomain, objects: List[str]):
        """
        Initialize code generator

        Args:
            state_graph: State graph from forward planning
            goal_name: Name of the goal (e.g., "on_a_b")
            domain: PDDL domain (for action definitions)
            objects: List of objects in domain
        """
        self.graph = state_graph
        self.goal_name = goal_name
        self.domain = domain
        self.objects = objects

    def generate(self) -> str:
        """
        Generate complete AgentSpeak code

        Returns:
            AgentSpeak .asl file content
        """
        sections = []

        # Header
        sections.append(self._generate_header())

        # Initial beliefs
        sections.append(self._generate_initial_beliefs())

        # Goal achievement plans
        sections.append(self._generate_goal_plans())

        # Success handler
        sections.append(self._generate_success_plan())

        # Failure handler
        sections.append(self._generate_failure_plan())

        return "\n\n".join(sections)

    def _generate_header(self) -> str:
        """Generate file header"""
        stats = self.graph.get_statistics()
        return f"""/* AgentSpeak Plan Library
 * Generated by Backward Planning (non-LLM)
 *
 * Goal: {self.goal_name}
 * Objects: {', '.join(self.objects)}
 *
 * Statistics:
 *   States: {stats['num_states']}
 *   Transitions: {stats['num_transitions']}
 *   Plans: {stats['num_states'] - 1}  // excluding goal state
 */"""

    def _generate_initial_beliefs(self) -> str:
        """
        Generate initial beliefs

        For blocksworld: all blocks on table, hand empty, all clear
        """
        lines = ["/* Initial Beliefs */"]

        # Blocksworld-specific initial beliefs
        for obj in self.objects:
            lines.append(f"ontable({obj}).")
            lines.append(f"clear({obj}).")

        lines.append("handempty.")

        return "\n".join(lines)

    def _generate_goal_plans(self) -> str:
        """
        Generate plans for achieving the goal

        For each non-goal state, generate a plan showing how to progress
        toward the goal.
        """
        lines = [f"/* Plans for goal: {self.goal_name} */"]

        # Find shortest paths to goal for all states
        paths = self.graph.find_shortest_paths_to_goal()

        # Generate plans for states that have paths to goal
        for state, path in paths.items():
            if state == self.graph.goal_state:
                # Skip goal state (handled by success plan)
                continue

            if not path:
                # No path to goal
                continue

            plan = self._generate_plan_for_state(state, path)
            lines.append(plan)

        return "\n\n".join(lines)

    def _generate_plan_for_state(self, state: WorldState,
                                  path: List[StateTransition]) -> str:
        """
        Generate AgentSpeak plan for a specific state

        Plan structure:
        +!goal_name : context <-
            !precond1;
            !precond2;
            action(args);
            +belief;
            -belief;
            !goal_name.

        Args:
            state: Current state
            path: Path to goal (list of transitions)

        Returns:
            AgentSpeak plan string
        """
        if not path:
            return self._generate_success_plan()

        # Get next transition in path
        next_transition = path[0]

        # Format context
        context = state.to_agentspeak_context()

        # Generate precondition subgoals
        subgoal_lines = []
        for precond in next_transition.preconditions:
            # Check if precondition is NOT satisfied in current state
            if not state.contains(precond):
                # Need to establish this precondition
                subgoal_name = self._predicate_to_goal_name(precond)
                subgoal_lines.append(f"!{subgoal_name}")

        # Format action call
        action_call = next_transition.get_action_call()

        # Get belief updates
        belief_update_lines = list(next_transition.belief_updates)

        # Build plan body
        body_lines = []
        body_lines.extend(subgoal_lines)
        body_lines.append(action_call)
        body_lines.extend(belief_update_lines)
        body_lines.append(f"!{self.goal_name}")  # Recursive call

        # Format body
        if len(body_lines) == 1:
            body = body_lines[0]
        else:
            body = ";\n    ".join(body_lines)

        # Generate plan
        plan = f"+!{self.goal_name} : {context} <-\n    {body}."

        return plan

    def _generate_success_plan(self) -> str:
        """Generate plan for when goal is already achieved"""
        context = self.graph.goal_state.to_agentspeak_context()

        return f"""+!{self.goal_name} : {context} <-
    .print("Goal {self.goal_name} already achieved!")."""

    def _generate_failure_plan(self) -> str:
        """Generate failure handler"""
        return f"""-!{self.goal_name} : true <-
    .print("Failed to achieve goal {self.goal_name}");
    .fail."""

    def _predicate_to_goal_name(self, predicate: PredicateAtom) -> str:
        """
        Convert predicate to goal name

        Args:
            predicate: PredicateAtom

        Returns:
            Goal name string (e.g., "on(a, b)" or "clear(c)")
        """
        # For now, just use the AgentSpeak format
        return predicate.to_agentspeak()


# Test function
def test_agentspeak_codegen():
    """Test AgentSpeak code generator"""
    print("="*80)
    print("Testing AgentSpeak Code Generator")
    print("="*80)

    # Create mock state graph
    from utils.pddl_parser import PDDLParser, PDDLAction

    # Load domain
    domain_file = Path(__file__).parent.parent / "legacy" / "fond" / "domains" / "blocksworld" / "domain.pddl"

    if not domain_file.exists():
        print(f"Domain file not found: {domain_file}")
        print("Skipping test")
        return

    domain = PDDLParser.parse_domain(str(domain_file))

    # Create simple state graph
    goal_state = WorldState({PredicateAtom("on", ["a", "b"])}, depth=0)
    state1 = WorldState({
        PredicateAtom("holding", ["a"]),
        PredicateAtom("clear", ["b"])
    }, depth=1)
    state2 = WorldState({
        PredicateAtom("ontable", ["a"]),
        PredicateAtom("clear", ["a"]),
        PredicateAtom("clear", ["b"]),
        PredicateAtom("handempty", [])
    }, depth=2)

    graph = StateGraph(goal_state)

    # Create mock action (use real action from domain)
    action_putonblock = None
    for action in domain.actions:
        if action.name == "put-on-block":
            action_putonblock = action
            break

    if action_putonblock is None:
        print("Action 'put-on-block' not found in domain")
        return

    # Add transitions
    trans1 = StateTransition(
        from_state=state1,
        to_state=goal_state,
        action=action_putonblock,
        action_args=["a", "b"],
        belief_updates=["+on(a, b)", "+handempty", "+clear(a)", "-holding(a)", "-clear(b)"],
        preconditions=[PredicateAtom("holding", ["a"]), PredicateAtom("clear", ["b"])]
    )
    graph.add_transition(trans1)

    action_pickupfromtable = None
    for action in domain.actions:
        if action.name == "pick-up-from-table":
            action_pickupfromtable = action
            break

    trans2 = StateTransition(
        from_state=state2,
        to_state=state1,
        action=action_pickupfromtable,
        action_args=["a"],
        belief_updates=["+holding(a)", "-handempty", "-ontable(a)"],
        preconditions=[PredicateAtom("handempty", []), PredicateAtom("clear", ["a"]), PredicateAtom("ontable", ["a"])]
    )
    graph.add_transition(trans2)

    # Generate code
    codegen = AgentSpeakCodeGenerator(
        state_graph=graph,
        goal_name="on(a, b)",
        domain=domain,
        objects=["a", "b"]
    )

    asl_code = codegen.generate()

    print("\nGenerated AgentSpeak Code:")
    print("="*80)
    print(asl_code)
    print("="*80)

    # Save to file
    output_file = Path(__file__).parent / "test_agentspeak_output.asl"
    with open(output_file, 'w') as f:
        f.write(asl_code)

    print(f"\nSaved to: {output_file}")
    print()


if __name__ == "__main__":
    test_agentspeak_codegen()
